package edu.iastate.cs472.proj1;

import java.io.FileNotFoundException;

/**
 * @author Aren Ashlock
 */

public class EightPuzzle {
	/**
	 * This static method solves an 8-puzzle with a given initial state using three heuristics. The first two, allowing single 
	 * moves only, compare the board configuration with the goal configuration by the number of mismatched tiles, and by the 
	 * Manhattan distance, respectively. The third heuristic, designed by yourself, allows double moves and must be also 
	 * admissible. The goal configuration set for all puzzles is
	 * 
	 * 			1 2 3
	 * 			8   4
	 * 			7 6 5
	 * 
	 * @param s0
	 * @return a string specified in the javadoc below
	 */
	public static String solve8Puzzle(State s0) {
		String programString = "";
		
		/* 
		1) If there exists no solution, return a message that starts with "No solution exists for the following initial 
	       state:" and follows with a blank line and then what would be the output from a call s0.toString(). See the end of 
		   Section 6 in the project description for an example. 
		*/
		if(!s0.solvable()) {
			programString = "No solution exists for the following initial state:\n\n" + s0.toString();
		}

		/* 
		2) Otherwise, solve the puzzle with the three heuristics. The two solutions generated by the first two heuristics 
		   may be different but must have the same length for optimality. 
		*/
		else {
			Heuristic h[] = {Heuristic.TileMismatch, Heuristic.ManhattanDist, Heuristic.DoubleMoveHeuristic}; 
			String[] moves = new String[3]; 
			
			for (int i = 0; i < 3; i++) {
				moves[i] = AStar(s0, h[i]);
			}
			
			/*
			3) Combine the three solution strings into one that would print out in the output format specified in Section 6 
			   of the project description.
			*/
			for(int i = 0; i < 3; i++) {
				programString += moves[i];
			}
		}

		return programString;
	}
	
	/**
	 * This method implements the A* algorithm to solve the 8-puzzle with an input initial state s0. 
	 * The algorithm implementation is described in Section 3 of the project description. 
	 * 
	 * Precondition: the puzzle is solvable with the initial state s0.
	 * 
	 * @param s0  initial state
	 * @param h   heuristic 
	 * @return    solution string 
	 */
	public static String AStar(State s0, Heuristic h) {
		State s = s0;
		
		// Initialize the two lists used by the algorithm. 
		OrderedStateList OPEN = new OrderedStateList(h, true); 
		OrderedStateList CLOSE = new OrderedStateList(h, false);		
		
		// Implement the algorithm described in Section 3 to solve the puzzle.
		OPEN.addState(s);

		//for(int a = 0; a < 2; a++) {
		while(OPEN.size() != 0) {
			s = OPEN.remove();
			CLOSE.addState(s);

			if(s.isGoalState()) {
				break;
			}

			else {
				int totalPossibleMoves;

				if(State.heu == Heuristic.DoubleMoveHeuristic) {
					totalPossibleMoves = 8;
				}
				else {
					totalPossibleMoves = 4;
				}

				for(int i = 0; i < totalPossibleMoves; i++) {
					try {
						State sucState = s.successorState(Move.values()[i]);

						if(s.predecessor != null) {
							if(!sucState.equals(s.predecessor)) {
								int newCost = sucState.cost();
								State foundState;

								if(OPEN.findState(sucState) != null) {
									// TODO
									foundState = OPEN.findState(sucState);
									int oldCost = foundState.cost();

									if(newCost < oldCost) {
										foundState.predecessor = s;
									}
								}
								else if(CLOSE.findState(sucState) != null) {
									// TODO
									foundState = CLOSE.findState(sucState);
									int oldCost = foundState.cost();

									if(newCost < oldCost) {
										OPEN.addState(foundState);
										foundState.predecessor = s;
									}
								}
								else {
									OPEN.addState(sucState);
								}
							}
						}
						else {
							int newCost = sucState.cost();
							State foundState;

							if(OPEN.findState(sucState) != null) {
								// TODO
								foundState = OPEN.findState(sucState);
								int oldCost = foundState.cost();

								if(newCost < oldCost) {
									foundState.predecessor = s;
								}
							}
							else if(CLOSE.findState(sucState) != null) {
								// TODO
								foundState = CLOSE.findState(sucState);
								int oldCost = foundState.cost();

								if(newCost < oldCost) {
									OPEN.addState(foundState);
									foundState.predecessor = s;
								}
							}
							else {
								OPEN.addState(sucState);
							}
						}
					} catch (IllegalArgumentException | CloneNotSupportedException e) {
						// Do nothing since it is not a valid move
					}
				}
			}
		}

		// Once a goal state s is reached, call solutionPath(s) and return the solution string.
		String solutionPathString = solutionPath(s);
			
		return solutionPathString;		
	}	
	
	/**
	 * From a goal state, follow the predecessor link to trace all the way back to the initial state. Meanwhile, generate a 
	 * string to represent board configurations in the reverse order, with the initial configuration appearing first. Between 
	 * every two consecutive configurations is the move that causes their transition. A blank line separates a move and a 
	 * configuration. In the string, the sequence is preceded by the total number of moves and a blank line. 
	 * 
	 * See Section 6 in the projection description for an example. 
	 * 
	 * Call the toString() method of the State class. 
	 * 
	 * @param goal
	 * @return
	 */
	private static String solutionPath(State goal) {
		String solution = "\n";
		State s = goal;

		// Initial board will have a null predecessor, so just check for that
		while(s.predecessor != null) {
			solution = s.move + "\n\n" + s.toString() + "\n\n" + solution;
			s = s.predecessor;
		}

		// Add the initial board to the solution string
		solution = s.toString() + "\n\n" + solution;

		// Add the header detailing numMoves and heuristic (depends on the current heuristic)
		if(State.heu == Heuristic.TileMismatch) {
			solution = goal.numMoves + " moves in total (heuristic: number of mismatched tiles)" + "\n\n" + solution;
		}
		else if(State.heu == Heuristic.ManhattanDist) {
			solution = goal.numMoves + " moves in total (heuristic: the Manhattan distance)" + "\n\n" + solution;
		}
		else {
			solution = goal.numMoves + " moves in total (heuristic: double moves allowed)" + "\n\n" + solution;
		}
		
		return solution; 
	}
}